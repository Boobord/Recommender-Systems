import pandas as pd
df = pd.read_csv('movies_metadata.csv')

# We also see that we have 24 columns
df.columns

#if we wanted to access the second movie in the DataFrame
second = df.iloc[1]

#Change the index to the title
df = df.set_index('title')

#Access the movie with title 'Jumanji'
jum = df.loc['Jumanji']

#Revert back to the previous zero-based indexing
df = df.reset_index()

#Create a smaller dataframe with a subset of all features
small_df = df[['title', 'release_date', 'budget', 'revenue', 'runtime', 'genres']]

#Output only the first 4 rows of small_df
small_df.head(4)

#Get information of the data types of each feature
#Columns with mixed (Text or mixed numeric and non-numeric values) types are stored with the object dtype.
small_df.info()

import warnings
warnings.filterwarnings("ignore")
import numpy as np
#Function to convert to float manually
def to_float(x):
    try:
        x = float(x)
    except:
        x = np.nan
    return x
#Apply the to_float function to all values in the budget column
small_df['budget'] = small_df['budget'].apply(to_float)
#Try converting to float using pandas astype
small_df['budget'] = small_df['budget'].astype('float')
#Get the data types for all features
small_df.info()

import warnings
warnings.filterwarnings("ignore")
#let's try to define a new feature, called year
#Convert release_date into pandas datetime format
small_df['release_date'] = pd.to_datetime(small_df['release_date'], errors='coerce' ) #If ‘coerce’, then invalid parsing will be set as NaN.

import warnings
warnings.filterwarnings("ignore")
#Extract year from the datetime
import numpy as np
small_df['year'] = small_df['release_date'].apply(lambda x: str(x).split('-')[0] if x != np.nan else np.nan)

#Display the DataFrame with the new 'year' feature
small_df.head()

#Sort DataFrame based on release year
small_df = small_df.sort_values('year')

#Sort Movies based on revenue (in descending order)
small_df = small_df.sort_values('revenue', ascending=False)

#Select only those movies which earned more than 1 billion
new = small_df[small_df['revenue'] > 1e9]

#Select only those movies which earned more than 1 billion and spent less than 150 million
new2 = small_df[(small_df['revenue'] > 1e9) & (small_df['budget'] < 1.5e8)]

#First, let's check out the shortest- and longest-running movies of all time¶
#Get the runtime Series object
runtime = small_df['runtime']

#Print the longest runtime of any movie
rmax=runtime.max()
print(rmax)

#Print the shortest runtime of any movie
print(runtime.min())

#Print the longest runtime of any movie
rmax=runtime.max()
print(rmax)

#It is also possible to calculate the mean and median of the Series¶

#Get the budget Series object
budget = small_df['budget']

#Print the mean budget of the movies
print(budget.mean())

#Print the median budget of the movies
print(new['budget'].median())

#Get the revenue Series object
revenue = small_df['revenue']

#Revenue generated by the 90th percentile movie
revenue.quantile(0.90)

#Get number of movies released each year
small_df['year'].value_counts()


















